% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/missRanger.R
\name{missRanger}
\alias{missRanger}
\title{missRanger}
\usage{
missRanger(
  data,
  formula = . ~ .,
  pmm.k = 0L,
  maxiter = 10L,
  seed = NULL,
  verbose = 1,
  returnOOB = FALSE,
  case.weights = NULL,
  ...
)
}
\arguments{
\item{data}{Un \code{data.frame} o \code{tibble} con valores faltantes para imputar.}

\item{formula}{Una formula de dos lados especificando las variables a ser imputadas (lado izquierdo) y variables usadas para imputar (lado derecho). Por defecto es . ~ ., en otras palabras, usar todas las variables para imputar todas las variables.
Si por ejemplo todas las variables (con datos faltantes) deberian ser imputadas por todas las variables excepto la variable "ID", usar . ~ . - ID. Notar que un "." es evaluado separadamente por cada lado de la fórmula. Tener en cuenta que las variables
con datos faltantes deben aparecer en el lado izquierdo si ellos deberian ser usados en el lado derecho.}

\item{pmm.k}{Numero de candidatos con valores no faltantes para muestrear desde la perspectiva del ppm. 0 para evitar este paso.}

\item{maxiter}{Maximo numero de iteraciones en cadena.}

\item{seed}{Semilla.}

\item{verbose}{Controla cuanta informacion es mostrada en la pantalla. 0 para mostrar nada. 1 (por defecto) muestra un "." por iteracion y variable, 2 para imprimir el error de prediccion OOB por iteracion y variable (1 menos R-cuadrado para regresion).
Ademas, si \code{verbose} es positivo, las variables usadas para imputacion son listadas como las variables a ser imputadas (en el orden de imputacion). Esto va a ser util para detectar si algunas variables son inesperadamente salteadas.}

\item{returnOOB}{Bandera logica. Si TRUE, el error promedio de la estimacion out-of-bag es adicionado al resultado como atributo "oob". Esto no funciona en el caso especial que las variables se imputen univariadamente.}

\item{case.weights}{Vector con caso de pesos no negativos.}

\item{...}{Argumentos pasados a \code{ranger}. Si la base de datos es larga, mejor usar menos arboles (e.g. \code{num.trees = 20}) y/o un bajo valor \code{sample.fraction}.
Los siguiente argumentos son, por ejemplo, incompatbles con \code{ranger}: \code{mtry}, \code{write.forest}, \code{probability}, \code{split.select.weights}, \code{dependent.variable.name}, y \code{classification}.}
}
\value{
Un imputado \code{data.frame}.
}
\description{
Usa el paquete "ranger" [1] para hacer una imputacion de valores faltantes por "chained random forest", ver [2] y [3].
Entre el ajuste del modelo iterativo, ofrece la opción de "predictive mean matching".
Esto hace que, en primer lugar, evite la imputación con valores que no estén presentes en la base original
(como el valor 0.558 en una variable binaria). Ademas, el ppm intenta elevar las varianzas en las distribuciones condicionales
resultantes a un nivel realistico y, como tal, permite una imputacion multiple al repetir la llamada al comando.
La encadenacion iterativa se detiene cuando \code{maxiter}
es alcanzado or si el promedio de la estimacion out-of-bag de rendimiento deja de mejorar. En el ultimo caso, excepto para la primera iteracion, la segunda ultima (o mejor) data imputada es retornada.
}
\details{
Imputacion rapida de valores faltantes por "chained random forest"
}
\examples{
irisWithNA <- genNAs(iris, seed = 34)
irisImputed <- missRanger(irisWithNA, pmm.k = 3, num.trees = 100)
head(irisImputed)
head(irisWithNA)

\dontrun{
# Algoritmo para arboles extra
irisImputed_et <- missRanger(irisWithNA, pmm.k = 3, num.trees = 100, splitrule = "extratrees")
head(irisImputed_et)

# No imputar "Species". Notar: Como esta variable contiene valores faltantes, no será usada
# para imputar otras variables.
head(irisImputed <- missRanger(irisWithNA, . - Species ~ ., pmm.k = 3, num.trees = 100))

# Imputar solo univariadamente.
head(irisImputed <- missRanger(irisWithNA, . ~ 1))

# Usar "Species" y "Petal.Length" para imputar "Species" y "Petal.Length".
head(irisImputed <- missRanger(irisWithNA, Species + Petal.Length ~ Species + Petal.Length,
                               pmm.k = 3, num.trees = 100))

# Imputacion multiple: Llena los datos 20 veces, corre 20 analisis y agrupa sus resultados.
require(mice)
filled <- replicate(20, missRanger(irisWithNA, verbose = 0, num.trees = 100, pmm.k = 5),
                    simplify = FALSE)
models <- lapply(filled, function(x) lm(Sepal.Length ~ ., x))
summary(pooled_fit <- pool(models)) # Realistically inflated standard errors and p values

# Un data set con valores logicos, numericos, caracteres and factores.
n <- 100
X <- data.frame(x1 = seq_len(n),
                x2 = log(seq_len(n)),
                x3 = sample(LETTERS[1:3], n, replace = TRUE),
                x4 = factor(sample(LETTERS[1:3], n, replace = TRUE)),
                x5 = seq_len(n) > 50)
head(X)
X_NA <- generateNA(X, p = seq(0, 0.8, by = .2))
head(X_NA)

head(X_imp <- missRanger(X_NA))
head(X_imp <- missRanger(X_NA, pmm = 3))
head(X_imp <- missRanger(X_NA, pmm = 3, verbose = 0))
head(X_imp <- missRanger(X_NA, pmm = 3, verbose = 2, returnOOB = TRUE))
attr(X_imp, "oob") # OOB prediction errors per column.

# El interfaz de la formula
head(X_imp <- missRanger(X_NA, x2 ~ x2 + x3, pmm = 3)) # Does not use x3 because of NAs
head(X_imp <- missRanger(X_NA, x2 + x3 ~ x2 + x3, pmm = 3))
head(X_imp <- missRanger(X_NA, x2 + x3 ~ 1, pmm = 3)) # Univariate imputation
}
}
\references{
[1] Wright, M. N. & Ziegler, A. (2016). ranger: A Fast Implementation of Random Forests for High Dimensional Data in C++ and R. Journal of Statistical Software, in press.
http://arxiv.org/abs/1508.04409.

[2] Stekhoven, D.J. and Buehlmann, P. (2012). 'MissForest - nonparametric missing value imputation for mixed-type data', Bioinformatics, 28(1) 2012, 112-118.
https://doi.org/10.1093/bioinformatics/btr597.

[3] Van Buuren, S., Groothuis-Oudshoorn, K. (2011). mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software, 45(3), 1-67.
http://www.jstatsoft.org/v45/i03/
}
\author{
Michael Mayer
}
